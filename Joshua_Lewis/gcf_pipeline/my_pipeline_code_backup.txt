
from build_dataset import get_latest_disaster_file, build_combined_rows, save_to_csv

def run_pipeline(request):
    try:
        file = get_latest_disaster_file()
        rows = build_combined_rows(file, limit=3)  # test with 3 to stay within limits
        save_to_csv(rows)
        return "‚úÖ Pipeline completed and CSV saved."
    except Exception as e:
        return f"‚ùå Pipeline failed: {e}"
import os
import glob
import csv
import uuid
import json
import pandas as pd
from datetime import datetime
from ambee_disater import get_disaster_cord
from testweather import get_weather_data
from open_street_test import reverse_geocode

# Load most recent disaster JSON file
def get_latest_disaster_file():
    files = sorted(glob.glob("disaster_data_*.json"), reverse=True)
    if not files:
        raise FileNotFoundError("‚ùå No disaster_data_*.json files found.")
    return files[0]

# Create final dataset row per disaster
def build_combined_rows(disaster_file, limit=10):
    rows = []

    for i in range(limit):
        try:
            # Step 1: Get lat/lon/timestamp
            disaster = get_disaster_cord(disaster_file, i)
            lat, lon, timestamp = disaster['lat'], disaster['lng'], disaster['date']
            timestamp_dt = datetime.strptime(timestamp, "%Y-%m-%d %H:%M:%S")

            # Step 2: Get weather
            weather = get_weather_data(lat, lon, timestamp)
            if not weather:
                print(f"‚ö†Ô∏è No weather data for disaster {i}, skipping...")
                continue

            # Step 3: Get address
            address = reverse_geocode(lat, lon)

            # Step 4: Combine
            row = {
                "event_id": str(uuid.uuid4()),
                "type": "UNKNOWN",  # Optional: replace if you can pull type from JSON
                "title": f"Disaster {i}",
                "timestamp": timestamp,
                "lat": lat,
                "lon": lon,
                "address": address,
                "temperature_2m": weather.get("temperature_2m"),
                "apparent_temperature": weather.get("apparent_temperature"),
                "precipitation": weather.get("precipitation"),
                "wind_speed_10m": weather.get("wind_speed_10m"),
                "wind_gusts_10m": weather.get("wind_gusts_10m"),
                "cloud_cover": weather.get("cloud_cover"),
                "weather_code": weather.get("weather_code")
            }

            rows.append(row)

        except Exception as e:
            print(f"‚ö†Ô∏è Skipping disaster {i} due to error: {e}")

    return rows

# Save rows to CSV
def save_to_csv(rows, filename="disaster_dataset.csv"):
    if not rows:
        print("‚ùå No data to save.")
        return

    keys = rows[0].keys()
    with open(filename, "w", newline="") as f:
        writer = csv.DictWriter(f, fieldnames=keys)
        writer.writeheader()
        writer.writerows(rows)
    print(f"‚úÖ Dataset saved to {filename}")

if __name__ == "__main__":
    try:
        file = get_latest_disaster_file()
        print(f"üìÇ Using disaster file: {file}")
        dataset_rows = build_combined_rows(file)
        save_to_csv(dataset_rows)
    except Exception as e:
        print(f"‚ùå Pipeline failed: {e}")
import requests
import json
from datetime import datetime
from dotenv import load_dotenv
import os
from pathlib import Path


BASE_DIR = Path(__file__).resolve().parent.parent
load_dotenv(BASE_DIR / ".env")
AMBEE_API_KEY = os.getenv("AMBEE_API_KEY")


def fetch_ambee_disasters(country_code='US'):

    if not AMBEE_API_KEY:
        print("ERROR: API key not found in environment variables")
        return None

    url = "https://api.ambeedata.com/disasters/latest/by-country-code"
    
    headers = {
        "x-api-key": AMBEE_API_KEY,
        "Content-type": "application/json",
        "Accept": "application/json"
    }
    
    params = {
        "countryCode": country_code
    }

    try:
        response = requests.get(url, headers=headers, params=params)
    
        
        if response.status_code != 200:
            return None
    
        return response.json()
        
    except requests.exceptions.RequestException as e:
        print(f"Network error: {str(e)}")
        return None
    except json.JSONDecodeError as e:
        print(f"JSON parsing error: {str(e)}")
        return None
    
def get_disaster_cord(filename, index):
    """
    Get coordinates of the disaster
    Args:
        disaster (dict): Disaster data
    Returns:
        dict: Coordinates of the disaster
    """

    with open(filename, 'r') as f: 
        disaster = json.load(f)
    
    if not disaster:
        print("No disaster data available")
        return None
    if 'result' not in disaster:
        print("No disaster data available")
        return None

    coordinates = disaster.get('result')[index]

    return {
        'lat': coordinates.get('lat', None),
        'lng': coordinates.get('lng', None),
        'date': coordinates.get('date', None)
    }


def display_disaster_info(data):
    """
    Display formatted disaster information
    Args:
        data (dict): JSON response from Ambee API
    """
    if not data or 'message' not in data:
        print("No data available")
        return

    print("\n=== Natural Disasters Report ===\n")
    
    for disaster in data.get('data', []):
        print(f"Type: {disaster.get('type', 'N/A')}")
        print(f"Title: {disaster.get('title', 'N/A')}")
        print(f"Description: {disaster.get('description', 'N/A')}")
        print(f"Severity: {disaster.get('severity', 'N/A')}")
        
        # Location information
        coordinates = get_disaster_cord(disaster)
        if coordinates:
            print(f"Location: Lat {coordinates['lat']}, "
                  f"Lon {coordinates['lng']}, "
                  f"Date {coordinates['date']}")
            
    
if __name__ == "__main__":
    print(os.listdir())
    # Fetch data for US
    print("Fetching natural disaster data from Ambee...")
    results = fetch_ambee_disasters(country_code="USA")

    
    if results:

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"disaster_data_{timestamp}.json"

        with open(filename, 'w') as f:
            json.dump(results, f, indent=2)
        print(f"\nData saved to {filename}")
        
        # Display formatted data
        print("\nDisplaying formatted data:")
        display_disaster_info(results)
        
        # Display raw JSON
        print("\nRaw JSON data:")
        print(json.dumps(results, indent=2))
    else:
        print("Failed to fetch data from Ambee API")import requests
import pandas as pd
from datetime import datetime, timedelta
from ambee_disater import get_disaster_cord
import os 
import json
import glob

def get_weather_data(latitude, longitude, disaster_timestamp):
    """
    Fetch hourly weather data from Open-Meteo Archive API
    and return the record closest to the disaster timestamp.
    """
    base_url = "https://api.open-meteo.com/v1/forecast"
 
    #"https://archive-api.open-meteo.com/v1/archive"

    # Parse string timestamp if needed
    if isinstance(disaster_timestamp, str):
        disaster_timestamp = datetime.strptime(disaster_timestamp, "%Y-%m-%d %H:%M:%S")
    
    start_date = disaster_timestamp.strftime("%Y-%m-%d")
    end_date = (disaster_timestamp + timedelta(days=1)).strftime("%Y-%m-%d")

    params = {
        "latitude": latitude,
        "longitude": longitude,
        "start_date": start_date,
        "end_date": end_date,
        "hourly": [
            "temperature_2m",
            "relative_humidity_2m",
            "apparent_temperature",
            "precipitation",
            "rain",
            "showers",
            "snowfall",
            "weather_code",
            "cloud_cover",
            "wind_speed_10m",
            "wind_direction_10m",
            "wind_gusts_10m"
        ],
        "timezone": "auto"
    }

    try:
        response = requests.get(base_url, params=params)
        response.raise_for_status()
        data = response.json()

        # Create DataFrame for hourly data
        hourly_df = pd.DataFrame(data['hourly'])
        hourly_df['time'] = pd.to_datetime(hourly_df['time'])

        # Find row with closest timestamp to disaster
        closest_idx = (hourly_df['time'] - disaster_timestamp).abs().idxmin()
        closest_weather = hourly_df.loc[closest_idx]

        return closest_weather.to_dict()

    except requests.RequestException as e:
        print(f"Error fetching weather data: {e}")
        return None
    except KeyError:
        print("Hourly data not found in response.")
        return None

if __name__ == "__main__":
    # Find the most recent disaster data JSON
    disaster_files = sorted(glob.glob(os.path.join(os.path.dirname(__file__), 'disaster_data_*.json')), reverse=True)
    if not disaster_files:
        raise FileNotFoundError("No disaster_data_*.json files found.")
    filename = disaster_files[0]
    print(f"Using disaster data from: {filename}")

    # Iterate through first 10 disaster entries
    for i in range(10): 
        try:
            lat, lng, date_str = get_disaster_cord(filename, i).values()
            print(f"\nüìç Disaster {i}: {date_str}")
            weather = get_weather_data(lat, lng, date_str)
            if weather:
                print("‚úÖ Closest Weather Observation:")
                serializable_weather = {k: (v.isoformat() if isinstance(v, pd.Timestamp) else v) for k, v in weather.items()}
                print(json.dumps(serializable_weather, indent=2))
        except Exception as e:
            print(f"‚ö†Ô∏è Skipping disaster {i} due to error: {e}")
import requests
import os
import glob
from ambee_disater import get_disaster_cord  # should return dict with lat, lng, timestamp

# Define your User-Agent info
USER_AGENT = "HomeportApp/1.0 (jlewis28@umd.edu)"

def reverse_geocode(lat, lon):
    """
    Convert latitude and longitude to an address using OSM Nominatim API.
    """
    url = "https://nominatim.openstreetmap.org/reverse"
    params = {"lat": lat, "lon": lon, "format": "json"}
    headers = {"User-Agent": USER_AGENT}

    response = requests.get(url, params=params, headers=headers)
    if response.status_code == 200:
        return response.json().get("display_name", "Address not found")
    else:
        print("Reverse geocoding failed.")
        return None

if __name__ == "__main__":
    # Find the most recent Ambee disaster JSON file
    disaster_files = sorted(glob.glob(os.path.join(os.path.dirname(__file__), 'disaster_data_*.json')), reverse=True)
    if not disaster_files:
        print("‚ùå No disaster data files found.")
        exit()

    filename = disaster_files[0]
    print(f"üìÇ Using disaster data from: {filename}")

    # Loop through disasters and reverse geocode each one
    for i in range(10):
        try:
            lat, lon, timestamp = get_disaster_cord(filename, i).values()
            print(f"\nüìç Disaster {i}: {timestamp} at ({lat}, {lon})")
            address = reverse_geocode(lat, lon)
            print(f"üè† Reverse geocoded address: {address}")
        except Exception as e:
            print(f"‚ö†Ô∏è Error with disaster {i}: {e}")
