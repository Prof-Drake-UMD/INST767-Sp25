# -*- coding: utf-8 -*-
"""issue1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PDSQA8YTsWS5TI3HRu50lZ_e8XectG-s

# **Issue 1:**
By now you should be set up and have this repository cloned and connected. Make your first commit by creating a README.md file. If you need a refresher on markdown go here. Edit the file to list the API data sources you intend to integrate. You should include any inputs to the APIs and the expected data that will come back.

Then, write some python code to make the api calls and pull the data down. These can be functions in the same .py file or separate files in a module. Either is fine. The functions should hit the api, gather the data that comes back, and have the JSON ready to be placed somewhere. Think of this as the beginning of the ingest phase.
"""

!pip install requests

import requests
import pandas as pd
import numpy as np
import os
import json
import random

timeless_themes = {
    "Identity": ["self", "individuality", "self-portrait", "gender", "nationality", "persona"],
    "Revolution": ["uprising", "protest", "freedom", "equality", "resistance", "overthrow"],
    "War": ["battle", "heroism", "violence", "peace", "soldiers", "exile"],
    "Love": ["passion", "heartbreak", "devotion", "desire", "marriage", "friendship"],
    "Nature": ["landscape", "flora", "fauna", "pastoral", "sublime", "seasons"],
    "Spirituality": ["divine", "sacred", "ritual", "faith", "transcendence", "salvation"],
    "Death": ["mortality", "mourning", "fate", "afterlife", "grief", "sacrifice"],
    "Society": ["social class", "inequality", "community", "domestic life", "urban life", "working class"],
    "Power": ["kingship", "empire", "tyranny", "oppression", "justice", "law"],
    "Freedom": ["liberty", "independence", "emancipation", "civil rights", "escape", "revolution"],
    "Myth": ["mythology", "gods", "hero", "folklore", "epic", "allegory"],
    "Journey": ["voyage", "pilgrimage", "exploration", "adventure", "odyssey", "exile"],
    "Technology": ["machinery", "industry", "progress", "innovation", "urbanization", "futurism"],
    "Gender": ["femininity", "masculinity", "gender roles", "sexuality", "love", "identity"],
    "Urban": ["city", "metropolis", "crowd", "nightlife", "modernity", "isolation"]
}

eras = {
    "Classical Antiquity": {
        "start_year": -800, "end_year": 500,
        "concepts": ["idealized form", "mythology", "harmony"]
    },
    "Medieval": {
        "start_year": 500, "end_year": 1400,
        "concepts": ["religious devotion", "symbolism", "Gothic"]
    },
    "Renaissance": {
        "start_year": 1400, "end_year": 1600,
        "concepts": ["humanism", "realism", "perspective"]
    },
    "Baroque": {
        "start_year": 1600, "end_year": 1750,
        "concepts": ["drama", "ornate", "exuberance"]
    },
    "Enlightenment": {
        "start_year": 1700, "end_year": 1800,
        "concepts": ["reason", "order", "symmetry"]
    },
    "Romanticism": {
        "start_year": 1780, "end_year": 1850,
        "concepts": ["emotion", "nature", "individualism"]
    },
    "Victorian": {
        "start_year": 1837, "end_year": 1901,
        "concepts": ["industrial", "moralism", "eclecticism"]
    },
    "Realism": {
        "start_year": 1850, "end_year": 1900,
        "concepts": ["social commentary", "truth", "naturalism"]
    },
    "Edo Period": {
        "start_year": 1603, "end_year": 1867,
        "concepts": ["ukiyo-e", "kabuki", "samurai culture"]
    },
    "Tang Dynasty": {
        "start_year": 618, "end_year": 907,
        "concepts": ["cosmopolitan", "landscape painting", "poetry"]
    },
    "Mughal Era": {
        "start_year": 1526, "end_year": 1857,
        "concepts": ["Persian fusion", "architecture", "miniatures"]
    },
    "Modernism": {
        "start_year": 1900, "end_year": 1945,
        "concepts": ["abstraction", "fragmentation", "innovation"]
    },
    "Postmodernism": {
        "start_year": 1960, "end_year": 2000,
        "concepts": ["irony", "pluralism", "pastiche"]
    },
    "Contemporary": {
        "start_year": 2000, "end_year": 2025,
        "concepts": ["digital", "global", "cross-cultural"]
    }
}

geography= {
    "French": ["Impressionist art", "Symbolist literature", "chanson", "Paris", "Bordeaux"],
    "British": ["Victorian literature", "folk music", "London art scene", "Shakespeare", "Oxford"],
    "American": ["Abstract Expressionism", "Jazz", "Hollywood", "Harlem", "Blues"],
    "Italian": ["Renaissance", "opera", "Futurism", "Rome", "Florence", "Venice"],
    "Russian": ["ballet", "Silver Age poetry", "iconography", "Moscow", "St. Petersburg"],
    "Chinese": ["Tang poetry", "calligraphy", "cinema", "dynasty", "landscape painting"],
    "Japanese": ["ukiyo-e", "anime", "J-pop", "kabuki", "haiku", "Tokyo"],
    "Indian": ["Mughal miniatures", "Bollywood", "raga", "Bengal", "Hindustani", "Deccan"],
    "West African": ["griot", "Afrobeat", "kente", "drumming", "oral tradition"],
    "Latin American": ["muralism", "Boom literature", "nueva canción", "Magical Realism", "Andes"],
    "Middle Eastern": ["Persian miniature", "Arabic calligraphy", "oud", "Sufi poetry"],
    "Harlem Renaissance": ["Jazz", "blues", "Black literature", "Harlem", "New Negro movement"]
}

influential_groups = {
    "Vienna Modernism": ["Gustav Klimt", "Stefan Zweig", "Richard Strauss"],
    "Harlem Renaissance": ["Langston Hughes", "Aaron Douglas", "Duke Ellington"],
    "Italian Futurism": ["F.T. Marinetti", "Umberto Boccioni", "Luigi Russolo"],
    "Parade Ballet (1917)": ["Pablo Picasso", "Jean Cocteau", "Erik Satie"],
    "Der Blaue Reiter": ["Wassily Kandinsky", "Arnold Schoenberg"],
    "Paris Romantic Salon": ["Frédéric Chopin", "George Sand", "Eugène Delacroix"],
    "Symbolist/Impressionist Circle": ["Stéphane Mallarmé", "Édouard Manet", "Claude Debussy"],
    "Bengal Renaissance": ["Rabindranath Tagore", "Abanindranath Tagore"]
}

CULTURAL_KEYWORDS = {
    "themes": timeless_themes,
    "eras": {k: v["concepts"] for k, v in eras.items()},
    "geography": geography,
    "collaborators": influential_groups
}

def get_met_artwork_by_keyword(keyword, label, theme_type):
    url = "https://collectionapi.metmuseum.org/public/collection/v1/search"
    params = {"q": keyword, "hasImages": True}
    resp = requests.get(url, params=params)
    ids = resp.json().get("objectIDs", [])
    if not ids:
        return None
    random.shuffle(ids)
    for object_id in ids[:10]:
        obj_url = f"https://collectionapi.metmuseum.org/public/collection/v1/objects/{object_id}"
        data = requests.get(obj_url).json()
        if data:
            return {
                "object_id": data.get("objectID"),
                "title": data.get("title"),
                "artist_name": data.get("artistDisplayName"),
                "object_date": data.get("objectDate"),
                "medium": data.get("medium"),
                "image_url": data.get("primaryImageSmall"),
                "object_url": data.get("objectURL"),
                "theme": label,
                "theme_type": theme_type,
                "ingest_ts": datetime.utcnow().isoformat()
            }
    return None

def get_book_by_keyword(keyword, label, theme_type):
    url = f"https://openlibrary.org/search.json?q={keyword}"
    resp = requests.get(url)
    docs = resp.json().get("docs", [])
    if not docs:
        return None
    for book in docs[:10]:
        return {
            "book_id": book.get("key"),
            "title": book.get("title"),
            "author_name": book.get("author_name", [None])[0],
            "first_publish_year": book.get("first_publish_year"),
            "language": book.get("language", [None])[0],
            "book_url": f"https://openlibrary.org{book.get('key')}",
            "theme": label,
            "theme_type": theme_type,
            "ingest_ts": datetime.utcnow().isoformat()
        }
    return None

def get_track_by_keyword(keyword, label, theme_type):
    url = "https://api.deezer.com/search"
    resp = requests.get(url, params={"q": keyword})
    tracks = resp.json().get("data", [])
    if not tracks:
        return None
    for track in tracks[:10]:
        return {
            "track_id": str(track.get("id")),
            "title": track.get("title_short"),
            "preview_url": track.get("preview"),
            "duration": track.get("duration"),
            "artist_name": track["artist"]["name"],
            "album_title": track["album"]["title"],
            "theme": label,
            "theme_type": theme_type,
            "ingest_ts": datetime.utcnow().isoformat()
        }
    return None

keyword = ["French", "Maurice Ravel"]
for t in keyword:
    print(" ")
    print(f"Theme: {t}")
    print(" ")
    print("Art:", get_met_artwork_by_theme(t))
    print("Book:", get_openlibrary_book_by_theme(t))
    print("Track:", get_music_track_by_theme_deezer(t))

met_sample_request = requests.get("https://collectionapi.metmuseum.org/public/collection/v1/objects/436121")
met_schema = met_sample_request.json()
print(met_schema.keys())

OL_sample_request = requests.get("https://openlibrary.org/search.json?q=pride+prejudice")
OL_schema = OL_sample_request.json()
print(OL_schema.keys())
print(OL_schema['docs'][0].keys())

deezer_sample_request = requests.get("https://api.deezer.com/search?q=joy")
deezer_schema = deezer_sample_request.json()
print(deezer_schema['data'][0].keys())

