# -*- coding: utf-8 -*-
"""Issue1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PDSQA8YTsWS5TI3HRu50lZ_e8XectG-s
"""

!pip install requests

import requests
import pandas as pd
import numpy as np
import os
import json
import random

THEME_KEYWORDS = {

    # Feelings
    "melancholy": ["weeping", "mourning", "solitude", "sadness"],
    "joy": ["celebration", "dancing", "laughter", "happiness", "festive"],
    "anger": ["rage", "fire", "battle", "clenched fist", "explosion", "pissed"],
    "hope": ["sunrise", "light", "dawn", "open sky", "faith"],
    "fear": ["shadows", "monster", "darkness", "isolation", "creep"],
    "love": ["kiss", "embrace", "romance", "valentine", "desire", "romantic"],
    "depressed": ["sad", "gloom", "down in the dumps", "broken-hearted", "crestfallen"],
    "lonely": ["isolated", "alone", "outcast", "forsaken", "abandoned"],
    "peaceful": ["at peace", "meditative", "restful", "harmonious", "relax"],

    # Aesthetic
    "gothic": ["cathedral", "graveyard", "skull", "dark", "ruins"],
    "surrealism": ["dream", "distortion", "floating", "dali", "eyeballs"],
    "minimalism": ["line", "shape", "geometry", "white", "silence"],
    "maximalism": ["pattern", "opulence", "decoration", "chaos", "colorful"],
    "cottagecore": ["flowers", "countryside", "basket", "tea", "woodland"],

    # Eras
    "romanticism": ["emotion", "nature", "storm", "hero", "freedom"],
    "baroque": ["gold", "ornate", "religion", "angel", "1600s"],
    "modernism": ["abstract", "geometry", "Bauhaus", "industrial", "progress"],
    "renaissance": ["portrait", "church", "Italy", "Leonardo", "fresco"],
    "1920s": ["jazz", "flapper", "cocktail", "art deco", "gatsby"],
    "medieval": ["armor", "castle", "sword", "illuminated", "crusade"],

    # Themes
    "revolution": ["freedom", "rebellion", "protest", "liberty", "flag"],
    "identity": ["portrait", "mirror", "self", "gender", "expression"],
    "death": ["skeleton", "mourning", "grave", "last supper", "ashes"],
    "nature": ["forest", "river", "animal", "tree", "landscape"],
    "mythology": ["gods", "serpent", "hero", "legend", "greek"],

    # Other
    "dark academia": ["book", "library", "quill", "gothic", "plaid", "ebon"],
    "light academia": ["sunlight", "pastel", "poetry", "cafe", "notebook"],
    "dreamy": ["misty", "ethereal", "daydream", "enchanting"],
}

def get_met_artwork_by_theme(theme):
  search_url= "https://collectionapi.metmuseum.org/public/collection/v1/search"
  params= {"q": theme, "hasImages":True}
  response= requests.get(search_url,params=params)
  data= response.json()
  object_ids= data["objectIDs"]

  if not data["objectIDs"]:
    return None

  random.shuffle(object_ids)

  for object_id in object_ids[:20]:
    object_url = f"https://collectionapi.metmuseum.org/public/collection/v1/objects/{object_id}"
    object_response = requests.get(object_url)
    object_data = object_response.json()

    return {
        "title": object_data.get("title"),
        "artist": object_data.get("artistDisplayName"),
        "date": object_data.get("objectDate"),
        "medium": object_data.get("medium"),
        "image": object_data.get("primaryImage"),
        "url": object_data.get("objectURL")
    }

def get_openlibrary_book_by_theme(theme):
    keyword = random.choice(THEME_KEYWORDS.get(theme.lower(), [theme]))

    search_url = f"https://openlibrary.org/search.json?q={keyword}"
    response = requests.get(search_url)
    data = response.json()

    if not data.get("docs"):
        print(f"No books found for theme: {theme} (keyword: {keyword})")
        return None

    random.shuffle(data["docs"])
    for doc in data["docs"]:
        if "title" in doc and "author_name" in doc:
            return {
                "title": doc["title"],
                "author": doc["author_name"][0] if doc["author_name"] else "Unknown",
                "publish_year": doc.get("first_publish_year"),
                "cover_url": f"https://covers.openlibrary.org/b/id/{doc['cover_i']}-L.jpg" if doc.get("cover_i") else None,
                "url": f"https://openlibrary.org{doc['key']}"
            }

    print(f"No suitable book found for theme: {theme}")
    return None

def get_music_track_by_theme_deezer(theme):
    keyword = random.choice(THEME_KEYWORDS.get(theme.lower(), [theme]))

    url = "https://api.deezer.com/search"
    params = {"q": keyword}
    headers = {
        "User-Agent": "Mozilla/5.0"
    }

    try:
        response = requests.get(url, params=params, headers=headers)
        response.raise_for_status()
        data = response.json()
    except Exception as e:
        print(f"Error accessing Deezer API: {e}")
        return None

    if not data.get("data"):
        print(f"No music found for theme: '{theme}' using keyword: '{keyword}'")
        return None

    random.shuffle(data["data"])
    for track in data["data"]:
        return {
            "track": track.get("title"),
            "artist": track["artist"]["name"],
            "album": track["album"]["title"],
            "preview_url": track.get("preview"),
            "deezer_url": track.get("link"),
            "album_cover": track["album"]["cover_medium"]
        }

    return None

themes = ["joy", "surrealism"]
for t in themes:
    print("Art:", get_met_artwork_by_theme(t))
    print("Book:", get_openlibrary_book_by_theme(t))
    print("Track:", get_music_track_by_theme_deezer(t))